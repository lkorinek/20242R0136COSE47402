{"task_id":"Rust/e1","prompt":"fn main(){}\n\nfn add_two_numbers(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn add_two_numbers(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"a + b\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add_two_numbers() {\n        assert_eq!(add_two_numbers(2, 3), 5);\n        assert_eq!(add_two_numbers(-1, 4), 3);\n    }\n}\n","buggy_solution":"fn add_two_numbers(a: i32, b: i32) -> i32 {\n    a * b\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"add_two_numbers","signature":"add_two_numbers(a: i32, b: i32) -> i32","docstring":"Adds two numbers.","instruction":"Write a Rust function `add_two_numbers(a: i32, b: i32) -> i32` that returns the sum of two integers."}
{"task_id":"Rust/e2","prompt":"fn main(){}\n\nfn subtract_two_numbers(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn subtract_two_numbers(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"a - b\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_subtract_two_numbers() {\n        assert_eq!(subtract_two_numbers(5, 3), 2);\n        assert_eq!(subtract_two_numbers(4, 7), -3);\n    }\n}\n","buggy_solution":"fn subtract_two_numbers(a: i32, b: i32) -> i32 {\n    a + b\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"subtract_two_numbers","signature":"subtract_two_numbers(a: i32, b: i32) -> i32","docstring":"Subtracts two numbers.","instruction":"Write a Rust function `subtract_two_numbers(a: i32, b: i32) -> i32` that returns the result of subtracting the second number from the first."}
{"task_id":"Rust/e3","prompt":"fn main(){}\n\nfn multiply_two_numbers(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn multiply_two_numbers(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"a * b\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_multiply_two_numbers() {\n        assert_eq!(multiply_two_numbers(3, 2), 6);\n        assert_eq!(multiply_two_numbers(-1, 5), -5);\n    }\n}\n","buggy_solution":"fn multiply_two_numbers(a: i32, b: i32) -> i32 {\n    a + b\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"multiply_two_numbers","signature":"multiply_two_numbers(a: i32, b: i32) -> i32","docstring":"Multiplies two numbers.","instruction":"Write a Rust function `multiply_two_numbers(a: i32, b: i32) -> i32` that returns the product of two integers."}
{"task_id":"Rust/e4","prompt":"fn main(){}\n\nfn divide_two_numbers(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn divide_two_numbers(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"a / b\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_divide_two_numbers() {\n        assert_eq!(divide_two_numbers(6, 3), 2);\n        assert_eq!(divide_two_numbers(10, 5), 2);\n    }\n}\n","buggy_solution":"fn divide_two_numbers(a: i32, b: i32) -> i32 {\n    a * b\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"divide_two_numbers","signature":"divide_two_numbers(a: i32, b: i32) -> i32","docstring":"Divides the first number by the second.","instruction":"Write a Rust function `divide_two_numbers(a: i32, b: i32) -> i32` that divides the first number by the second."}
{"task_id":"Rust/e5","prompt":"fn main(){}\n\nfn is_even(n: i32) -> bool {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_even(n: i32) -> bool {\n\n","canonical_solution":"n % 2 == 0\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_even() {\n        assert_eq!(is_even(4), true);\n        assert_eq!(is_even(5), false);\n    }\n}\n","buggy_solution":"fn is_even(n: i32) -> bool {\n    n % 2 != 0\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"is_even","signature":"is_even(n: i32) -> bool","docstring":"Checks if the number is even.","instruction":"Write a Rust function `is_even(n: i32) -> bool` that returns `true` if the number is even, `false` otherwise."}
{"task_id":"Rust/e6","prompt":"fn main(){}\n\nfn is_odd(n: i32) -> bool {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_odd(n: i32) -> bool {\n\n","canonical_solution":"n % 2 != 0\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_odd() {\n        assert_eq!(is_odd(3), true);\n        assert_eq!(is_odd(4), false);\n    }\n}\n","buggy_solution":"fn is_odd(n: i32) -> bool {\n    n % 2 == 0\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"is_odd","signature":"is_odd(n: i32) -> bool","docstring":"Checks if the number is odd.","instruction":"Write a Rust function `is_odd(n: i32) -> bool` that returns `true` if the number is odd, `false` otherwise."}
{"task_id":"Rust/e7","prompt":"fn main(){}\n\nfn square_number(n: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn square_number(n: i32) -> i32 {\n\n","canonical_solution":"n * n\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_square_number() {\n        assert_eq!(square_number(3), 9);\n        assert_eq!(square_number(4), 16);\n    }\n}\n","buggy_solution":"fn square_number(n: i32) -> i32 {\n    n + n\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"square_number","signature":"square_number(n: i32) -> i32","docstring":"Returns the square of the number.","instruction":"Write a Rust function `square_number(n: i32) -> i32` that returns the square of the given number."}
{"task_id":"Rust/e8","prompt":"fn main(){}\n\nfn find_max(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_max(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"if a > b { a } else { b }\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_max() {\n        assert_eq!(find_max(3, 5), 5);\n        assert_eq!(find_max(7, 2), 7);\n    }\n}\n","buggy_solution":"fn find_max(a: i32, b: i32) -> i32 {\n    if a < b { a } else { b }\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"find_max","signature":"find_max(a: i32, b: i32) -> i32","docstring":"Finds the maximum of two numbers.","instruction":"Write a Rust function `find_max(a: i32, b: i32) -> i32` that returns the larger of the two numbers."}
{"task_id":"Rust/e9","prompt":"fn main(){}\n\nfn find_min(a: i32, b: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn find_min(a: i32, b: i32) -> i32 {\n\n","canonical_solution":"if a < b { a } else { b }\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_find_min() {\n        assert_eq!(find_min(3, 5), 3);\n        assert_eq!(find_min(7, 2), 2);\n    }\n}\n","buggy_solution":"fn find_min(a: i32, b: i32) -> i32 {\n    if a > b { a } else { b }\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"find_min","signature":"find_min(a: i32, b: i32) -> i32","docstring":"Finds the minimum of two numbers.","instruction":"Write a Rust function `find_min(a: i32, b: i32) -> i32` that returns the smaller of the two numbers."}
{"task_id":"Rust/e10","prompt":"fn main(){}\n\nfn double_number(n: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn double_number(n: i32) -> i32 {\n\n","canonical_solution":"n * 2\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_double_number() {\n        assert_eq!(double_number(2), 4);\n        assert_eq!(double_number(5), 10);\n    }\n}\n","buggy_solution":"fn double_number(n: i32) -> i32 {\n    n + n\n}","bug_type":"incorrect operation","failure_symptoms":"incorrect output","entry_point":"double_number","signature":"double_number(n: i32) -> i32","docstring":"Doubles the given number.","instruction":"Write a Rust function `double_number(n: i32) -> i32` that returns double the value of the input."}
{"task_id":"Rust/e11","prompt":"fn main(){}\n\nfn factorial(n: u32) -> u32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn factorial(n: u32) -> u32 {\n\n","canonical_solution":"if n == 0 { 1 } else { n * factorial(n - 1) }\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_factorial() {\n        assert_eq!(factorial(0), 1);\n        assert_eq!(factorial(5), 120);\n    }\n}\n","buggy_solution":"fn factorial(n: u32) -> u32 {\n    n * factorial(n - 1)\n}","bug_type":"missing base case","failure_symptoms":"stack overflow","entry_point":"factorial","signature":"factorial(n: u32) -> u32","docstring":"Calculates the factorial of a non-negative integer.","instruction":"Write a Rust function `factorial(n: u32) -> u32` that calculates the factorial of a given number recursively."}
{"task_id":"Rust/e12","prompt":"fn main(){}\n\nfn power(base: i32, exponent: u32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn power(base: i32, exponent: u32) -> i32 {\n\n","canonical_solution":"if exponent == 0 { 1 } else { base * power(base, exponent - 1) }\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_power() {\n        assert_eq!(power(2, 3), 8);\n        assert_eq!(power(5, 0), 1);\n    }\n}\n","buggy_solution":"fn power(base: i32, exponent: u32) -> i32 {\n    base * power(base, exponent - 1)\n}","bug_type":"missing base case","failure_symptoms":"stack overflow","entry_point":"power","signature":"power(base: i32, exponent: u32) -> i32","docstring":"Calculates the power of a base raised to an exponent.","instruction":"Write a Rust function `power(base: i32, exponent: u32) -> i32` that calculates the result of raising the base to the given exponent recursively."}
{"task_id":"Rust/e13","prompt":"fn main(){}\n\nfn absolute_value(n: i32) -> i32 {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn absolute_value(n: i32) -> i32 {\n\n","canonical_solution":"if n < 0 { -n } else { n }\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_absolute_value() {\n        assert_eq!(absolute_value(-5), 5);\n        assert_eq!(absolute_value(3), 3);\n    }\n}\n","buggy_solution":"fn absolute_value(n: i32) -> i32 {\n    n\n}","bug_type":"missing condition","failure_symptoms":"incorrect output","entry_point":"absolute_value","signature":"absolute_value(n: i32) -> i32","docstring":"Returns the absolute value of a number.","instruction":"Write a Rust function `absolute_value(n: i32) -> i32` that returns the absolute value of an integer."}
{"task_id":"Rust/e14","prompt":"fn main(){}\n\nfn is_palindrome(s: &str) -> bool {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn is_palindrome(s: &str) -> bool {\n\n","canonical_solution":"let s = s.to_lowercase();\n    s.chars().eq(s.chars().rev())\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_is_palindrome() {\n        assert_eq!(is_palindrome(\"racecar\"), true);\n        assert_eq!(is_palindrome(\"hello\"), false);\n    }\n}\n","buggy_solution":"fn is_palindrome(s: &str) -> bool {\n    s.chars().eq(s.chars().rev())\n}","bug_type":"case sensitivity","failure_symptoms":"incorrect output","entry_point":"is_palindrome","signature":"is_palindrome(s: &str) -> bool","docstring":"Checks if a string is a palindrome.","instruction":"Write a Rust function `is_palindrome(s: &str) -> bool` that returns true if the input string is a palindrome."}
{"task_id":"Rust/e15","prompt":"fn main(){}\n\nfn reverse_string(s: &str) -> String {\n\n","declaration":"\nuse std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\nuse rand::Rng;\nuse regex::Regex;\nuse md5;\nuse std::any::{Any, TypeId};\n\nfn reverse_string(s: &str) -> String {\n\n","canonical_solution":"s.chars().rev().collect()\n}","test":"#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        assert_eq!(reverse_string(\"hello\"), \"olleh\");\n        assert_eq!(reverse_string(\"rust\"), \"tsur\");\n    }\n}\n","buggy_solution":"fn reverse_string(s: &str) -> String {\n    s.to_string()\n}","bug_type":"missing reversal","failure_symptoms":"incorrect output","entry_point":"reverse_string","signature":"reverse_string(s: &str) -> String","docstring":"Reverses the given string.","instruction":"Write a Rust function `reverse_string(s: &str) -> String` that returns the reversed version of the input string."}
